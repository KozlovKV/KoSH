/*
  Основной модуль шелла. Комментарии для большинства функций находятся в shell.c
*/
#pragma once

#include "shell_structs.h"

extern int terminalDescriptor;
extern pid_t shellPgid;
extern struct termios defaultTerminalSettings;
extern int bgFreeNumber; // Счётчик, который инкрементируется при каждом добавлении задачи в фон. Гарантирует не пересечение IDшников (в рамках значений знакового int'а, но, думаю, этого более чем достаточно)
extern Job* headBgJobFake; // Фальшивая первая фоновая задача. Реальные задачи будет прикрепляться к ней
extern char readInterruptionFlag; // Флаг для печати переноса строки при прерывании чтения сигналом
extern char prompt[1024];

/*
  Проводит первичную настройку шелла:
  - Создаёт отдельную группу для шелла
  - Назначает эту группу группой первого плана для терминала
  - Отключает реакцию на сигналы управления группами и переназначает обработчик сигнала для SIGINT
  - Создаёт фальшивую фоновую задачу
*/
void initShell();

/*
  Функция, не делающая ничего. Просто ставить SIG_IGN я не стал для красоты с печатью нового промпта
*/
void handleSigInt();
/*
  Назначает функцию выше обработчиком SIGINT, используя sigaction
*/
void setSigIntHandler();

/*
  Считывает из stdin длинную строку, возвращая её размер. В случае прерывания чтения сигналом,
  поставит readInterruptionFlag = 1 и завершится, вернув единицу для продолжения цикла
*/
int promptline(char *prompt, char *line, int sizline);
/*
  Получает путь до текущей директории процесса и обновляет промпт
*/
char* updatePrompt();


/*
  Парсит полученную из функции выше строку на аргументы и спецсимволы, конструируя новый список задач и процессов в них, 
  голову которого вернёт к результат либо NULL при неудаче. В этой функции вызываются createJob и createProcess, выделяющие память динамически.
  При неудачном парсинге выделенная память будет тут же очищена
*/
Job* parseline(char *);

/*
  Основной обработчик задачи. 
  Проходится по всем процессам в задаче и вызывает для них форк.
  
  В новом процессе:
  - Переводит процесс в группу задачи либо создаёт её, если это первый процесс
  - Возвращает обработчики сигналов на дэфолтные
  - Переопределяет ввод-вывод при помощи setInputOutputRedirection
  - Пытается исполнить шелл-специфичные форк-команды (см. shell_cmds.h)
  - При неудаче проводит execvp

  В родительском процессе:
  - Сохраняет ID созданного потомка и группы задачи
  - Отправляет дочерний процесс в группу его задачи

  После обработки всех процессов в списке задачи:
  - Если задача помечена флагом initialFg
    - Назначает её группу группой первого плана для терминала
    - Запускает waitFgJob
    - Назначает обратно группой первого плана группу шелла и восстанавливает дэфолтные настройки терминала
  - Иначе отправляет процесс в фон при помощи addJobToBg
*/
int processJob(Job* job);

/*
  Закрывает дескриптор targetFd и копирует на его место дескриптор sourceFd
*/
int substituteDescriptor(int sourceFd, int targetFd);
/*
  Проводит все необходимые переназначения ввода-вывода для данного процесса:
  - В соответствии с флагом пайпов у процесса
  - Проверяя переопределения ввода для первого процесса в задаче и вывода для последнего
*/
void setInputOutputRedirection(Job* job, Process* process, int* prevPipes, int* newPipes);

/*
  Опрашивает процессы в группе задачи переднего плана, сохраняя информацию о событиях в её процессах
  Опрос завершится, когда завершатся любым образом все процессы либо когда какой-либо из них будет остановлен
  В случае завершения процессов в задаче, будет вызван freeJob
*/
void waitFgJob(Job* job);

/*
  Добавляет задачу в конец списка фоновых задач и возвращает выделенный ей номер фоновой задачи
*/
int addJobToBg(Job* job);