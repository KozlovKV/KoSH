# Normal README will be soon...

# ШЕЛЛ С УПРАВЛЕНИЕМ ЗАДАНИЯМИ. Козлов Кирилл, 22215
## Сборка
Для сборки самого шелла используйте команду `make` либо `make main`. Шелл соберётся в файл `main.out`

Для сборки дополнительных утилит вызовите `make utils`:
- `./plus_one.out` - читает число из `stdin` и выводит инкрементированное число в `stderr` и `stdout`. (*По нему можно построить длинную цепочку пайпов*)
- `./write_with_delay.out <delay> <message>` - после истечения таймера выведется в `stdout` аргумент `message`. Засыпание сделано при помощи `sleep`, поэтому, если процесс остановить в фоне, то при передаче ему команды на продолжение, он может тут же вывести сообщение, если реально `delay` секунд уже прошло

## Реализованные фичи
Синтаксические:
- Последовательное независимое выполнение команд через `;`
- Отправление команды в фон при помощи `&` (также выступает разделителем между командами, то есть если у нас будет `<cmd1> & <cmd2>`, то в фон отправится только `cmd1`)
- Пайпы `|`
- Перенаправление ввода `<`, вывода `>` либо `>>` для режима `append`
- Чтение текста в кавычках как единого аргумента (*да-да, в исходном шаблоне такого не было!*)

Шелл-специфичные команды:
- `jobs` - выводит список фоновых заданий
- `fg %<job_number>` - переводит на передний план задание с номером `job_number` (указывается в квадратных скобках при выводе задачи)
- `bg %<job_number>` - продолжит выполнение остановленной задачи в фоне
- `kill %<job_number>` - убивает фоновый процесс (`kill <pid>` также работает корректно)
- `cd <path>` - переход по абсолютному или относительному пути `path` (на данный момент `~` для перехода в домашнюю папку надо писать отдельно, то есть без какого-либо пути после)

Все сигналы работают ожидаемым образом: `SIGINT` и `SIGTSTP` игнорируются шеллом и получаются задачей первого плана, которая будет убита или остановлена и переведена в список фоновых соответственно; `SIGQUIT` пошлёт шеллу `EOF` и тот завершит свою работу, послав всем фоновым процессам `SIGHUP` (насколько я понял, в обычном шелле этого не происходит, и фоновые процессы продолжают исполнение, но я решил пока что сделать так. Могу без проблем убрать это действие)

## Общее описание алгоритма
1. Проводим преднастройку процесса командной оболочки
2. Считываем команды до тех пор, пока не получен `EOF`
3. Считанную команду парсим для получения информации о задачах и процессах, память для которых выделяется динамически
   1. Задачи хранят информацию о перенаправлении ввода-вывода и о необходимости запуска задачи в фоне
   2. Процессы хранятся в задаче списком, каждый процесс хранит в себе аргументы команды и флаги пайпы на вход и выход
4. Перед запуском каждой следующей задачи обновляем информацию о фоновых задачах
5. Запускаем каждую задачу и процесс в ней, отправляя нужные задачи в фон, переназначая нужным образом ввод-вывод
6. Для задач первого плана будет проведена очистка памяти по завершение задачи
7. Память из-под фоновых задач будет освобождена в случае, когда при очередном опросе их статус был изменён на завершённый

## Примеры интересных команд
```bash
echo 4 > input.txt ; ./plus_one.out | ./plus_one.out | ./plus_one.out | ./plus_one.out | ./plus_one.out | ./plus_one.out | ./plus_one.out < input.txt >> input.txt
```

```bash
./write_with_delay.out 10 aaa
# Жмём Ctrl+Z. Теперь aaa не будет выведено, пока мы не пропишем fg либо bg. Можем прописать и kill
./write_with_delay.out 10 aaa > output.txt &
# output.txt создастся сразу, а вот aaa появится в нём через 10 секунд
```

*Ну и многое другое...*